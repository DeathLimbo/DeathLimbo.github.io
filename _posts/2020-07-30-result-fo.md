---
layout: post
title: 杂谈-设计异步 RESTful APIs
date: 2020-07-30
categories: 函数总结
tags: [异步,RESTful APIs]
description: 文章金句。
---
# 场景 #
## 常用web场景 ##
一个不同的 Web 应用通常不会遇到需要异步 RESTful API 的场景，它们的交互逻辑固定为：<br>
- 客户端请求 –> 服务端程序与数据库交互 –> 响应客户端。 <br>

### 问题假设 ###
现在假设我们的业务非常的复杂，需要后端进行长时间的处理（比如，五分钟），那么我们应该如何设计 RESTful API 来与客户端进行异步任务交互呢？
- 异步事务过程: <br>
 1、客户端请求 -> 服务端接收到请求 -> 异步启动任务 -> 响应客户端任务已接受 <br>
 2、客户端请求 -> 服务端收到任务进度查询请求 -> 查看任务进度 -> 响应客户端任务的执行状态 <br>

# 异步 RESTful 产生问题 #
- 接口幂等性的保证让客户端生成而是服务端分配？ <br>
 1、支持客户端在 POST 请求 Body 中包含一个保证幂等性的唯一标识 <br>
 2、通过先通过一个接口让服务端分配一个异步任务的事务 ID，然后客户端收到此 ID 后凭借此 ID 进行后续操作<br>
    差异:1、第二种 好处在于:服务端完整的掌控的所有的异步事务<br>
## 场景描述 ##
客户端 A 和 客户端 B 同时使用了相同的标识符来做幂等性的保证，那么服务端必须鉴别这两个相同的标识是来自不同的客户端实体。这可以通过在请求中增加额外的身份验证来完成，但这进一步增加了服务端的复杂度以及客户端与服务端之间的交互成本。<br>
- 为什么不选择 WebSocket？ <br>
  描述:假设我们同时接受了百万级别的异步任务，那么服务端必须维护百万级别的长连接从而通知客户端异步任务的执行状态<br>
  这样有很好的比较：一百万的并发和一百万的长连接，压力对比一下子就出来了，并且websocket后还会引入很多额外的诸如断线重连、主动关闭、主动关闭失败等等错误处理
  坏处:<br>
  1、一方面增加了客户端和服务端之间的交互的开发成本<b2>
  2、另一方面还引入了额外的系统复杂性<br>
- 服务端的异步任务如何对任务进度进行记录？
  问题描述:服务端的任务调度器也不知道这个任务要多久才会执行完毕<br>
  问题解决:事实上这样的场景只会发生在某个任务的第一次执行中，服务端可以对不同的任务进行鉴别，自然也可以对不同任务的执行时间进行统计<br>
  例子解决:客户端发起请求需要服务端执行任务 A ，服务端查询统计记录了解到任务 A 在所有历史记录中平均需要 158 秒，那么服务端可以以此为标准，直接假设任务 A 的执行时间为 158 秒，那么当客户端的查询请求到达后，比较请求提交时间和查询时间，从而推算任务进度<br>
  例子方案:具体计算公式为：任务进度 = （查询请求到达时间 - 创建任务时间）/ 平均任务时间，如果任务进度计算结果大于等于 1，则任务进度为 99%。当异步任务执行完毕后，再讲任务进度主动更新为 100%<br>
  
- 如何让客户端从请求结果中识别异步任务成功还是失败？ <br>
 1、定时轮询: <br>
 ## 坏处 ## 
 <1、>定时轮询需要消耗大量的客户端发送请求资源和服务端处理资源。 <br>
 解决:在 HTTP 请求 Header 中有一个 Retry-After 字段。那么，当一个客户端任务请求到达后，服务端首先检查任务是否有历史记录，如果有则统计平均任务完成时间（或者最长完成时间），并在 Retry-After 中附上此时间，从而客户端可以得知在何时再发送历史请求，而无需进行不必要的定时轮询浪费资源<br>
 
- 如果异步任务失败了，服务端需要对异步任务涉及的资源作何处理？ <br>
客户端解决: <br>
1、一个是客户端在查询请求中始终遵循服务端 Retry-After 的原则，如果某一次 Retry-After 后请求失败，则可以认为任务是执行失败的<br>
2、另一个方法是，客户端记录每次 Retry-After 查询到的任务进度，如果接口在进度小于 100% 的情况下失败了，那么也可以认为任务是失败的<br>
服务端解决: <br>
当一个异步任务失败后，我们需要设计一个被动的销毁任务，让异步任务中涉及的相关操作进行回滚或者删除，例如当客户端在申请某个创建资源后，却没有创建成功，则销毁任务应将此资源创建过程中涉及的中间产物一并销毁 <br>

- ...

# 接口设计 #
Get /api/v1/task 返回一个服务端分配的唯一标识 <br>
POST /api/v1/task/:uuid 当客户端获得唯一标识后，可以通过请求此接口来提交异步任务，并返回 202 Accepted。<br>
GET /api/v1/task/:uuid 当客户端提交异步任务后，可以通过此接口来查询异步任务的执行结果 <br>
PUT /api/v1/task/:uuid 当客户端提交异步任务后，可以通过此接口来更新一些异步任务的信息 <br>
DELETE /api/v1/task/:uuid 有需要的场景下，可以通过此接口来让客户端主动发起销毁异步任务（包括异步任务产生的资源等数据），当销毁任务执行后 /api/v1/task/:uuid 所有的操作均不能使用，返回无效事务的错误。<br>


# 总结 #
1、服务端分配异步事务的唯一标识 <br>
2、服务端的对客户端请求的异步事务执行进行统计 <br>
3、服务端需要实现异步事务失败的被动被动销毁任务 <br>
4、服务端需要在返回请求时一并告知客户端下一次主动与服务端交互的时间 <br>

