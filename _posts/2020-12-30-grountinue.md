---
layout: post 
title: go-goroutine 
date: 2021-1-22 
categories: arr 
tags: [go,goroutine]
description: 文章金句。
---

# 浅谈进程、线程 #
eg：当运行一个应用程序（如一个IDE或编辑器）的时候，操作系统回味这个应用程序启动一个<h2>进程</h2>,可以将这个进程看作一个包含了应用程序的容器,然后在这个进程下面包含了多个线程（至少包含一个），并且第一个启动的线程叫做主线程。因为这个线程的空间是应用程序的本身的空间，所以当主线程终止时，应用程序也会终止。
如下图所示:
![img](https://deathlimbo.github.io/img/gro/1.jpg)

# golang的并发 #
go语言的并发同步模型来自于一个叫做通信顺序进程(csp)的泛型。
## csp定义 ##
一个并发系统由若干并行运行的顺序进程组成，每个进程不能对其他进程的变量赋值。进程之间只能通过 一对通信原语实现协作：Q->x表示从进程Q输入一个值到变量x中；P<-e表示把表达式e的值发送给进程P。当P进程执行Q->x， 同时Q进程执行P<-e时，发生通信，e的值从Q进程传送给P进程的变量x。后来出现的实用编程语言OCCAM即以CSP为基础发展而成。
## golang的并发模型 ##
### 结构体 ###
G:代表一个goroutine，一个G可以绑定到一个P（逻辑调度器）上，他的结构体是在runtime.go,里面存储了将近40个成员变量<br>
P:逻辑调度器，将G安排到M（cpu）上面执行,P的数量与机器的内核数量相等，可以使用GOMAXPROCS函数设置内核数量<br>
M:线程,他的结构体则有runtime.m，因为他要用p来连接G，所以里面存储了一些有关于G的一些成员变量,他的数量也与机器的内核数量相等，可以使用GOMAXPROCS函数设置内核数量<br>
### 三者之间的关系 ###
 在程序运行之初，假设默认启动四个线程四个处理器，之间相互绑定，此时一个goroutine启动起来，他在进行函数体地址、参数起始地址、参数长度等信息以及调度相关属性更新之后,则会随机进入一个空闲的P（逻辑处理器）当中等待M的调用<br>
 如果此时另一个goroutine也启动了起来，则他会寻找空闲的P（逻辑处理器）等待M的调用，如果此时所有的P都不空闲，则这个G就会进入全局队列里面等待调用<br>
 M的执行逻辑则是去寻找以及装配了P的G去执行，如果此时有空闲的M，且P已经全部在执行，则他会去全局队列里面寻找未被执行的G来执行，此时如果全局队列里面如果没有的话，则他回去帮忙在其他的线程里面偷G来运行，如果此时G和另一个G正在通过channel通信的话，则M会放弃这两个G执行，如果此时还未找到可以执行的G，则M会去睡觉（idle）了

### 系统调用 ###
如果此时G进行了系统调用，那么M也会跟着进行系统调用， 那么P则会放弃跟进这个G，会去寻找其他的M执行。<br>
后面这个G执行完了系统调用，他会被筛入全局队列，等待调用

### sysmon ###
sysmon是我们的保洁阿姨，它是一个M，又叫监控线程，不需要P就可以独立运行，每20us~10ms会被唤醒一次出来打扫卫生，主要工作就是回收垃圾、回收长时间系统调度阻塞的P、向长时间运行的G发出抢占调度等等。