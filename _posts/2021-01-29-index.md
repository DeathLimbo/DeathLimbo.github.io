---
layout: post 
title: mysql-索引
date: 2021-1-29
categories: mysql
tags: [mysql,index]
description: 文章金句。
---
#                                       索引介绍                        #
-------------------------------------------------------------------------<br>
## 索引是什么 ##
索引相当于字典的目录，是为了帮组mysql更快的查询到数据的一种数据结构。<br>
索引一般来说时存储在磁盘上的文件但中的，我们通常说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织的索引.<br>
## 索引的优势劣势 ##
### 优势 ### 
 ·可以提高数据检索效率，减少磁盘io成本<br>
 ·通过索引列对数据进行排序，降低数据排序成本，降低cpu的消耗<br>
      ·被索引的列会自动经行排序，包括单列索引、组合索引，只是组合索引的排序要复杂一些<br>
      ·如果按照索引列的顺序进行排序，对应order by来说 ，效率就会提高很多<br>
### 劣势 ###
 ·索引会占磁盘空间<br>
 ·索引虽然会提高查询效率，但是会降低更新表的效率<br>
 
#                                      索引类型                          #
----------------------------------------------------------------------------<br>
## 主键索引 ##
索引列的值必须是唯一的，不允许为空值
## 普通索引 ##
mysql的基本类型索引，没有什么限制，允许定义索引的列中插入重复值和空值
## 唯一索引 ##
索引列必须唯一，但是允许空值
## 全文索引 ## 
只能在char、varchar、text类型字段上创建全文索引，如果字段长度比较大时，如果创建普通索引，在进行like模糊查询的时候效率较低，这个时候可以创建全文索引，myisam和innodb中都可以使用全文索引
## 空间索引 ##
MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则
## 前缀索引 ##
在文本类型如char、varchar、text类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定
## 其他 ##
1、单列索引<br>
2、组合索引<br>
   组合索引的使用，需要遵循<h2>最左前缀匹配原则</h2>。一般情况下在条件运行的情况下使用组合索引代替多个单列索引
#                                      索引的数据结构                          #
----------------------------------------------------------------------------<br>
## hash表 ##
Hash表，以键值对的方式存储数据。我们使用Hash表存储表数据key可以存储索引列,value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为o(1)，但是不支持范围快速查找，范围快速查找只能通过扫描全表的方式<br>

## 二叉查找树 ##
![img](https://deathlimbo.github.io/img/index/1.png)
二叉树的特点：每个节点最多有两个分叉，左子树和右子树顺序左小右大。<br>
这个特点就是为了保证每次查找都可以折半而减少io次数，但是二叉树就是很考验第一个根节点的取值，因为很容易在这个特点下发生“树不分叉了”。<br>
![img](https://deathlimbo.github.io/img/index/2.png)
## 平衡二叉树 ##
平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征时左右两个子树的层级最多相差1。在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。<br>
使用平衡二叉查找树查询的性能接近二分查找法，时间复杂度是O(log2n).<br>
![img](https://deathlimbo.github.io/img/index/1.png)
缺点:<br>
 1、时间复杂度和树高相关。<br>
 2、平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率不高<br>
## B树:改造二叉树 ##
因为在MySQL的InnoDB存储引擎一次IO会读取的一页（默认一页16K）的数据量，而二叉树一次IO有效数据量只有16字节，空间利用率极低。为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000=1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。<br>
这种数据结构我们成为B树，B树是一种多叉平衡查找树，有以下主要特点:<br>
    1、B树的节点中存储着多个元素，每个内节点有多个分叉<br>
    2、节点中的元素包含键值和数据，节点中的键值从大到小排列，也就是说，所有的节点都储存数据<br>
    3、父节点的元素不会出现在子节点中<br>
    4、所有的节点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针链接<br>
![img](https://deathlimbo.github.io/img/index/3.png)
B树可以优化的地方:<br>
 1、B树不支持范围查询的快速查找<br>
 2、如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大，这时一个页中可存储的数据量就会变少，树相应就变高
## B+树:改造B树 ##
 B树：非叶子节点和叶子节点都会存储数据。 <br>
 B+树：只有叶子节点才会存储数据，非叶子节点至存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。 <br>
![img](https://deathlimbo.github.io/img/index/4.png)
 B+树的最底层叶子节点包含了所有的索引项。从图上可以看到，B+树在查找数据的时候，由于数据都存放在最底层的叶子节点上，所以每次查找都需要检索到叶子节点才能查询到数据。<br>
 所以在需要查询数据的情况下每次的磁盘的IO跟树高有直接的关系，但是从另一方面来说，由于数据都被放到了叶子节点，放索引的磁盘块锁存放的索引数量是会跟这增加的，相对于B树来说，B+树的树高理论上情况下是比B树要矮的。<br>
 也存在索引覆盖查询的情况，在索引中数据满足了当前查询语句所需要的全部数据，此时只需要找到索引即可立刻返回，不需要检索到最底层的叶子节点。<br>
#                                      Mysql的索引实现                          #
----------------------------------------------------------------------------<br>
## MyIsam索引
以一个简单的user表为例，usr表存在两个索引，id列为主键索引，age列为普通索引<br>
![img](https://deathlimbo.github.io/img/index/5.png)
![img](https://deathlimbo.github.io/img/index/6.png)
 MyIsam的数据文件和索引文件是分开存储的，myisam使用B+树构建索引树时，叶子节点中存储的键值为索引列的值，数据为索引所在行的磁盘地址。<br>
 
### 根据主键等值查询数据： ###
 select * from user where id = 28;<br>
 磁盘IO次数：3次索引检索+记录数据检索。<br>
![img](https://deathlimbo.github.io/img/index/7.png)
### 根据主键范围查询数据： ###
select * from user where id between 28 and 47;<br>
磁盘IO次数：4次索引检索+记录数据检索。<br>
![img](https://deathlimbo.github.io/img/index/8.png)
<h3>备注：</h3>以上分析仅供参考，MyISAM在查询时，会将索引节点缓存在MySQL缓存中，而数据缓存依赖于操作系统自身的缓存，所以并不是每次都是走的磁盘，这里只是为了分析索引的使用过程。
### 辅助索引 ###
在 MyISAM 中,辅助索引和主键索引的结构是一样的，没有任何区别，叶子节点的数据存储的都是行记录的磁盘地址。只是主键索引的键值是唯一的，而辅助索引的键值可以重复。 <br>
查询数据时，由于辅助索引的键值不唯一，可能存在多个拥有相同的记录，所以即使是等值查询，也需要按照范围查询的方式在辅助索引树中检索数据。<br>

## InnoDb索引 ##
<h2>主键索引(聚簇索引)</h2>
每个InnoDB表都有一个聚簇索引，聚簇索引使用B+树构建，叶子节点存储的数据是整行记录，一般情况下，聚簇索引等同于主键索引，当一个表没有创建主键索引时，InnoDb会自动创建一个ROWID字段来构建聚簇索引,具体规则如下：<br>
 1、在表上定义主键PRIMARY KEY ,innodb将主键索引用作聚簇索引<br>
 2、如果表没有主键，则会选择第一个不为Null的唯一索引列用作聚簇索引<br>
 3、如果以上两个都没有，则innnodb会使用一个6字节长整型的隐式字段rowID字段构建聚簇索引，该rowid字段会在插入新行时自动递增<br>
<br>
<br>
除聚簇索引之外的所有索引都称为辅助索引，在InnodB中，辅助索引中的叶子节点存储的数据是该行的主键值，在检索时，innodb使用此主键值在聚簇索引中搜索行记录<br>

以一个简单的user表为例，usr表存在两个索引，id列为主键索引，age列为普通索引<br>
![img](https://deathlimbo.github.io/img/index/5.png)
![img](https://deathlimbo.github.io/img/index/6.png)
InnoDB的数据和索引存储在一个文件t_user_innodb.ibd中。InnoDB的数据组织方式，是聚簇索引。<br>
![img](https://deathlimbo.github.io/img/index/9.png)

### 根据主键等值查询数据： ###
 select * from user where id = 28;<br>
 磁盘IO次数：3次索引检索<br>
![img](https://deathlimbo.github.io/img/index/10.png)
### 辅助索引 ###
除聚簇索引之外的所有索引都称为辅助索引，InnoDb的辅助索引只会存储主键值而非磁盘地址.<br>
![img](https://deathlimbo.github.io/img/index/11.png)
当等值查询走辅助索引时:<br>
![img](https://deathlimbo.github.io/img/index/12.png)
磁盘IO数：辅助索引3次+获取记录回表3次
### 组合索引 ###
还是以自己创建的一个表为例：表 abc_innodb，id为主键索引，创建了一个联合索引idx_abc(a,b,c)。<br> 
 ![img](https://deathlimbo.github.io/img/index/13.png)
 select * from abc_innodb order by a, b, c, id;
 ![img](https://deathlimbo.github.io/img/index/14.png)
 <h4>组合索引的查询过程:</h4><br>
 select * from abc_innodb where a = 13 and b = 16 and c = 4;
 ![img](https://deathlimbo.github.io/img/index/15.png)
#### 最左匹配原则: #### 
最左前缀匹配原则和联合索引的索引存储结构和检索方式是有关系的。<br>
在组合索引树中，最底层的叶子节点按照第一列a列从左到右递增排列，但是b列和c列是无序的，b列只有在a列值相等的情况下小范围内递增有序，而c列只能在a，b两列相等的情况下小范围内递增有序。<br>
就像上面的查询，B+树会先比较a列来确定下一步应该搜索的方向，往左还是往右。如果a列相同再比较b列。但是如果查询条件没有a列，B+树就不知道第一步应该从哪个节点查起。<br>
组合索引的最左前缀匹配原则：使用组合索引查询时，mysql会一直向右匹配直至遇到范围查询(>、<、between、like)就停止匹配。<br>
#### 覆盖索引 ####
覆盖索引并不是说是索引结构，覆盖索引是一种很常用的优化手段。因为在使用辅助索引的时候，我们只可以拿到主键值，相当于获取数据还需要再根据主键查询主键索引再获取到数据。但是试想下这么一种情况，在上面abc_innodb表中的组合索引查询时，如果我只需要abc字段的，那是不是意味着我们查询到组合索引的叶子节点就可以直接返回了，而不需要回表。这种情况就是覆盖索引。

#                                      索引优化                         #
----------------------------------------------------------------------------<br>
## 1、避免回表 ##
在innoDb的存储引擎中，使用辅助索引时，因为辅助索引叶子节点保存的数据不是当前记录的数据而是当前记录的主键索引，索引如果需要获取当前记录完整数据必然需要根据主键值从主键索引继续查询，这个过程我们称为回表。

如果在一个场景下，select id,name,sex from user where name ='zhangsan';这个语句在业务上频繁使用到，而user表的其他字段使用频率远低于它，在这种情况下，如果我们在建立 name 字段的索引的时候，不是使用单一索引，而是使用联合索引（name，sex）这样的话再执行这个查询语句是不是根据辅助索引查询到的结果就可以获取当前语句的完整数据。<br>

## 2、避免回表 ##
联合索引，在建立索引的时候，尽量在多个单列索引上判断下是否可以使用联合索引。联合索引的使用不仅可以节省空间，还可以更容易的使用到索引覆盖。<br>
试想一下，索引的字段越多，是不是更容易满足查询需要返回的数据呢。比如联合索引（a_b_c），是不是等于有了索引：a，a_b，a_b_c三个索引，这样是不是节省了空间，当然节省的空间并不是三倍于（a，a_b，a_b_c）三个索引，因为索引树的数据没变，但是索引data字段的数据确实真实的节省了。<br>
### 联合索引创建规则 ###
在创建联合索引的时候因该把频繁使用的列、区分度高的列放在前面，频繁使用代表索引利用率高，区分度高代表筛选粒度大，这些都是在索引创建的需要考虑到的优化场景，也可以在常需要作为查询返回的字段上增加到联合索引中，如果在联合索引上增加一个字段而使用到了覆盖索引，那我建议这种情况下使用联合索引。<br>
### 联合索引的使用 ###

考虑当前是否已经存在多个可以合并的单列索引，如果有，那么将当前多个单列索引创建为一个联合索引。 <br>
当前索引存在频繁使用作为返回字段的列，这个时候就可以考虑当前列是否可以加入到当前已经存在索引上，使其查询语句可以使用到覆盖索引。<br>
[摘自三太子敖丙](https://mp.weixin.qq.com/s/faOaXRQM8p0kwseSHaMCbg)






