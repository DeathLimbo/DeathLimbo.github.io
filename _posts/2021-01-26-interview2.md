---
layout: post 
title: go面试【1】-mysql
date: 2021-1-23
categories: interview
tags: [面试,mysql]
description: 文章金句。
---
## 索引相关 ##
### 1、什么是索引? ###
索引是一种数据结构，可以帮我们快速的进行数据的查找
### 2、索引是个什么样的数据结构呢? ###
索引的数据结构跟mysql存储引擎有关，5.6过后默认使用的innodb，使用的是b+数索引,以前则使用的是mysalrm使用的是hash索引<br>
### 3、Hash索引和B+树所有有什么区别或者说优劣呢 ###
hash索引:底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据，<br>
B+树:实现是多路平衡查找树，对于每次的查询都是从根节点出发，查找到叶子节点方向可以获得所查键值，然后根据查询判断是否需要回表查询<br>
不同:<br>
1、hash索引等值查询更快，但是无法进行范围查询(因为hash索引中经过hash函数建立索引后，索引的顺序与原顺序无法保持一致，不支持范围查询,而B+树所有节点遵循左节点小于父节点，右节点大于父节点，多叉树也类似，天然支持范围)<br>
2、hash索引不支持使用索引进行排序，理由同上<br>
3、hash索引不支持模糊查询以及多列索引的最左前缀匹配，因为hash函数的不可预测<br>
4、hash函数任何时候都不可避免回表查询，而B+树在符合某些条件(聚簇索引、覆盖索引等)的时候可以只通过索引完成查询<br>
5、hash索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生了hash碰撞，性能可能较差，而B+树的查询效率比较稳定，对于所有的查询都是从跟节点到叶子节点，且树的高度较低<br>
因此大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引<br>
### 4、聚簇索引、覆盖索引 ###
在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行数据，这就是聚簇索引和非聚簇索引。<br>
在innodb中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引，如果没有唯一键，则隐式的生成一个键来建立聚簇索引.<br>
当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。<br>
### 5、非聚簇索引一定会回表查询吗 ###
不一定，如果查询语句的字段全部命中了索引，那么就不必进行回表查询.
eg:<br>
 例如我们在员工表的年龄上建立了索引，那么当进行select age from usr where age >10 的查询时，在索引的叶子节点上，以及包含了age信息，不会再次进行回表查询
### 6、在建立索引的时候,都有哪些需要考虑的因素 ###
需要考虑到字段的使用频率，经常作为条件进行查询的字段比较适合，如果需要建立联合索引的话，还需要考虑联合索引的顺序（遵循最左前缀匹配）,还有就是许愿哦防止过的索引对表造成的压过过大<br>
### 7、联合索引 ###
mysql中使用多个字段同时建立一个索引叫做联合索引<br>
在联合索引当中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引<br>
### 8. 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因 ###
mysql提供了explain命令来查看语句的执行计划，则可以看到是否命中索引等信息。
### 9、那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢 ###
1、使用了<>查询<br>
2、列参与了数学运算或者函数<br>
3、like 左边是通配符,eg"%11" <br>
4、当mysql分析全表扫描比使用索引快的时候不适用索引<br>
5、当使用联合索引，前面一个条件作为范围查询，后面的即使符合最左前缀原则，也无法使用索引<br>
## 事务相关 ##
### 1、什么是事务 ###
事务是一系列的操作，他们符合acid特性<br>
事务的特性:<br>
1、原子性(A=Atomicity):一个事务当中要么全部完成。要么全部不完成<br>
2、一致性(C=Consistency):在事务开始之前和事务结束之后，数据库的完整性没有被破坏<br>
3、持久性(D=Durability)：对数据的修改是永久的<br>
4、隔离性(I=Isolation):事务之间不会相互影响<br>
事务的隔离级别:读未提交，读已提交，可重复读，串行读，innodb默认为可重复读
### 2、同时有多个事务在进行会怎么样呢?###
多事务的并发一般会造成以下几个问题:<br>
 1、脏读：A事务读取到了B事务的未提交内容，而B事务后面进行了回滚<br>
 2、不可重复读:当设置A事务只能读取B事务已经提交的部分，会造成A事务内的两次查询，结果竟然不一样，因为再次期间B事务进行了提交操作<br>
 3、幻读:A事务读取了一个范围的内容，而同时B事务再次期间插入了一条数据，造成幻觉
### 3、怎么解决这些问题呢?MySQL的事务隔离级别了解吗? ###
隔离级别如下: <br>
 1、未提交读:这就是上面所说的例外情况了，在这个隔离级别下，其他事务可以看到本事务没有提交的部分修改，因此会造成脏读问题(读到了其他事务未提交的部分，而之后该事务进行了回滚)<br>
 2、已提交读:其他事务只能读取到本事务已经提交的部分，这个隔离级别有不可重复读的问题，在同一个事务内的两次读取，拿到的竟然不一样这是因为另一个事务对数据进行了修改<br>
 3、可重复读:可重复读解决了上面的不可重复读，但是任然有一个问题:幻读，当读取id >10的数据行时，对涉及到的所有行加上了读锁，此时另外一个事务插入了一条id=11的数据，因为是新插入的，所以不会触发上面的锁的排斥，那么进行本事务进行下一次的查询时就会发现有一条id=11的数据，而上次的查询操作没有获取到，在进行插入就会有主键冲突的问题<br>
 4、可串行读:可串行读解决了上面的所有问题，但他强制将所有的操作串行执行，这会导致并发性能下降，所以并不常用<br>
### 4、MySQL的锁 ###
当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的顺序，锁机制就是这样的机制。
### 5、MySQL都有哪些锁呢?像上面那样子进行锁定岂不是有点阻碍并发效率了? ###
共享锁:读锁，当用户需要进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个<br>
排他锁:写锁，当用户进行数据的写入时，对数据加上排他锁，排他锁只能加上一个，他和其他的排他锁，共享锁都相斥<br>
锁的粒度取决于具体的存储引擎，innodb实现了行级锁，页级锁，表级锁，他们的加锁开销、并发能力从大到校<br>
## 表结构设计 ##
### 1、为什么要尽量设定一个主键 ###
主键是数据库保证行数据在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键，设定了逐渐之后，在后续的增删改查可能更快加速以及确保操作数据范围安全
### 2、主键使用自增ID还是UUID? ###
推荐使用自增ID，不建议使用UUID<br>
因为在innodb的存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增的ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降<br>
### 3、字段为什么要求定义为not null###
null值会占用更多的字节，且会在程序中造成很多预期不符的情况。
### 4、如果要存储用户的密码散列,应该使用什么字段进行存储 ###
密码散列、盐、用户身份证等固定长度的字符串应该使用char而不是vachar，这样既可以节省空间且提高检索效率。
## 存储引擎 ##
### 1、mysql支持哪些存储引擎 ###
mysql支持多种存储引擎，比如innodb,mylsam,memory,archive等等，在大多数的情况下，直接选择使用innodb引擎都是最合适的，innodb也是mysql在5.6过后的默认引擎<br>
innodb和mylsam的区别:<br>
    1、innodb支持事务，mylsam不支持<br>
    2、innodb支持行级锁，mylsam支持表级锁<br>
    3、innodb支持mvcc(多版本并发控制),mylsam不支持<br>
    4、innodb支持外键，mylsam不支持
    5、innodb支持全文索引，mylsam支持
## 零散问题 ##
### 1、 MySQL中的varchar和char有什么区别 ###
char是一个定长字段，加入申请了char(10)的空间，那么无论存储多少内容，该字段都占用10个字符，而varchar是边长的，也就是说申请的只是最大长度，占用的空间为实际字符长度+1<br>
在效率上来说 char > varchar ，因此在使用过程中，如果确定了某个字段的值的长度，则可以使用char，否则应该使用varchar，例如存储用户MD5加密后的密码，则应该使用char
### 2、varchar(10) 和 int(10)代表什么含义 ###
varchar的10代表申请的空间长度，也是可以存储的数据的最大长度，而int的10只是代表了展示的长度，不足10位以0填充，也就是说int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的，只是展示时按照长度展示<br>















