---
layout: post 
title: go面试【2】-mysql
date: 2021-1-23
categories: interview
tags: [面试,mysql]
description: 文章金句。
---
## 索引相关 ##
### 1、什么是索引? ###
索引是一种数据结构，可以帮我们快速的进行数据的查找
### 2、索引是个什么样的数据结构呢? ###
索引的数据结构跟mysql存储引擎有关，5.6过后默认使用的innodb，使用的是b+数索引,以前则使用的是mysalrm使用的是hash索引<br>
### 3、Hash索引和B+树所有有什么区别或者说优劣呢 ###
hash索引:底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据，<br>
B+树:实现是多路平衡查找树，对于每次的查询都是从根节点出发，查找到叶子节点方向可以获得所查键值，然后根据查询判断是否需要回表查询<br>
不同:<br>
1、hash索引等值查询更快，但是无法进行范围查询(因为hash索引中经过hash函数建立索引后，索引的顺序与原顺序无法保持一致，不支持范围查询,而B+树所有节点遵循左节点小于父节点，右节点大于父节点，多叉树也类似，天然支持范围)<br>
2、hash索引不支持使用索引进行排序，理由同上<br>
3、hash索引不支持模糊查询以及多列索引的最左前缀匹配，因为hash函数的不可预测<br>
4、hash函数任何时候都不可避免回表查询，而B+树在符合某些条件(聚簇索引、覆盖索引等)的时候可以只通过索引完成查询<br>
5、hash索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生了hash碰撞，性能可能较差，而B+树的查询效率比较稳定，对于所有的查询都是从跟节点到叶子节点，且树的高度较低<br>
因此大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引<br>
### 4、聚簇索引、覆盖索引 ###
在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行数据，这就是聚簇索引和非聚簇索引。<br>
在innodb中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引，如果没有唯一键，则隐式的生成一个键来建立聚簇索引.<br>
当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。<br>
### 5、非聚簇索引一定会回表查询吗 ###
不一定，如果查询语句的字段全部命中了索引，那么就不必进行回表查询.
eg:<br>
 例如我们在员工表的年龄上建立了索引，那么当进行select age from usr where age >10 的查询时，在索引的叶子节点上，以及包含了age信息，不会再次进行回表查询
### 6、在建立索引的时候,都有哪些需要考虑的因素 ###
需要考虑到字段的使用频率，经常作为条件进行查询的字段比较适合，如果需要建立联合索引的话，还需要考虑联合索引的顺序（遵循最左前缀匹配）,还有就是许愿哦防止过的索引对表造成的压过过大<br>
### 7、联合索引 ###
mysql中使用多个字段同时建立一个索引叫做联合索引<br>
在联合索引当中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引<br>
### 8. 创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因 ###
mysql提供了explain命令来查看语句的执行计划，则可以看到是否命中索引等信息。
### 9、那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢 ###
1、使用了<>查询<br>
2、列参与了数学运算或者函数<br>
3、like 左边是通配符,eg"%11" <br>
4、当mysql分析全表扫描比使用索引快的时候不适用索引<br>
5、当使用联合索引，前面一个条件作为范围查询，后面的即使符合最左前缀原则，也无法使用索引<br>
## 事务相关 ##
### 1、什么是事务 ###
事务是一系列的操作，他们符合acid特性<br>
事务的特性:<br>
1、原子性(A=Atomicity):一个事务当中要么全部完成。要么全部不完成<br>
2、一致性(C=Consistency):在事务开始之前和事务结束之后，数据库的完整性没有被破坏<br>
3、持久性(D=Durability)：对数据的修改是永久的<br>
4、隔离性(I=Isolation):事务之间不会相互影响<br>
事务的隔离级别:读未提交，读已提交，可重复读，串行读，innodb默认为可重复读
### 2、同时有多个事务在进行会怎么样呢?###
多事务的并发一般会造成以下几个问题:<br>
 1、脏读：A事务读取到了B事务的未提交内容，而B事务后面进行了回滚<br>
 2、不可重复读:当设置A事务只能读取B事务已经提交的部分，会造成A事务内的两次查询，结果竟然不一样，因为再次期间B事务进行了提交操作<br>
 3、幻读:A事务读取了一个范围的内容，而同时B事务再次期间插入了一条数据，造成幻觉
### 3、怎么解决这些问题呢?MySQL的事务隔离级别了解吗? ###
隔离级别如下: <br>
 1、未提交读:这就是上面所说的例外情况了，在这个隔离级别下，其他事务可以看到本事务没有提交的部分修改，因此会造成脏读问题(读到了其他事务未提交的部分，而之后该事务进行了回滚)<br>
 2、已提交读:其他事务只能读取到本事务已经提交的部分，这个隔离级别有不可重复读的问题，在同一个事务内的两次读取，拿到的竟然不一样这是因为另一个事务对数据进行了修改<br>
 3、可重复读:可重复读解决了上面的不可重复读，但是任然有一个问题:幻读，当读取id >10的数据行时，对涉及到的所有行加上了读锁，此时另外一个事务插入了一条id=11的数据，因为是新插入的，所以不会触发上面的锁的排斥，那么进行本事务进行下一次的查询时就会发现有一条id=11的数据，而上次的查询操作没有获取到，在进行插入就会有主键冲突的问题<br>
 4、可串行读:可串行读解决了上面的所有问题，但他强制将所有的操作串行执行，这会导致并发性能下降，所以并不常用<br>
### 4、MySQL的锁 ###
当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的顺序，锁机制就是这样的机制。
### 5、MySQL都有哪些锁呢?像上面那样子进行锁定岂不是有点阻碍并发效率了? ###
共享锁:读锁，当用户需要进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个<br>
排他锁:写锁，当用户进行数据的写入时，对数据加上排他锁，排他锁只能加上一个，他和其他的排他锁，共享锁都相斥<br>
锁的粒度取决于具体的存储引擎，innodb实现了行级锁，页级锁，表级锁，他们的加锁开销、并发能力从大到校<br>
## 表结构设计 ##
### 1、为什么要尽量设定一个主键 ###
主键是数据库保证行数据在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键，设定了逐渐之后，在后续的增删改查可能更快加速以及确保操作数据范围安全
### 2、主键使用自增ID还是UUID? ###
推荐使用自增ID，不建议使用UUID<br>
因为在innodb的存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增的ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降<br>
### 3、字段为什么要求定义为not null ###
null值会占用更多的字节，且会在程序中造成很多预期不符的情况。
### 4、如果要存储用户的密码散列,应该使用什么字段进行存储 ###
密码散列、盐、用户身份证等固定长度的字符串应该使用char而不是vachar，这样既可以节省空间且提高检索效率。
## 存储引擎 ##
### 1、mysql支持哪些存储引擎 ###
mysql支持多种存储引擎，比如innodb,mylsam,memory,archive等等，在大多数的情况下，直接选择使用innodb引擎都是最合适的，innodb也是mysql在5.6过后的默认引擎<br>
innodb和mylsam的区别:<br>
    1、innodb支持事务，mylsam不支持<br>
    2、innodb支持行级锁，mylsam支持表级锁<br>
    3、innodb支持mvcc(多版本并发控制),mylsam不支持<br>
    4、innodb支持外键，mylsam不支持
    5、innodb支持全文索引，mylsam支持
## 零散问题 ##
### 1、 MySQL中的varchar和char有什么区别 ###
char是一个定长字段，加入申请了char(10)的空间，那么无论存储多少内容，该字段都占用10个字符，而varchar是边长的，也就是说申请的只是最大长度，占用的空间为实际字符长度+1<br>
在效率上来说 char > varchar ，因此在使用过程中，如果确定了某个字段的值的长度，则可以使用char，否则应该使用varchar，例如存储用户MD5加密后的密码，则应该使用char
### 2、varchar(10) 和 int(10)代表什么含义 ###
varchar的10代表申请的空间长度，也是可以存储的数据的最大长度，而int的10只是代表了展示的长度，不足10位以0填充，也就是说int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的，只是展示时按照长度展示<br>
### 3、MySQL的binlog有有几种录入格式?分别有什么区别? ###
binlog:记录所有数据库结构变更以及表数据修改的二进制日志
有三种录入格式: <br>
 1、statement模式下，记录单元为语句，即每一个sql造成的影响会记录，由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制<br>
 2、row级别，记录单元为每一行的改动，基本是可以全部记下来，但是由于很多操作，会导致大量行的改动，因此这种模式的文件保存的信息太多，日志量太大<br>
 3、mixed：一种折中的方案，普通操作使用statement记录，当无法使用statement的是时候使用row<br>
### 4、 超大分页怎么处理? ###
1、数据库层面:这是我们集中关注的，类似于 select * from table where age > 20 limit 100000,10这种查询是可以有优化的余地，这条语句需要load100000数据然后基本上全部丢弃，只取10条，当然比较慢，这是我们可以修改为 select * from table where id in (select id from table where age > 20 limit 100000,19)，这样虽然load了一百万的数据，但是由于索引覆盖，要查询的所有字段都在索引中，所以速度会很快，核心思想都是:减少load的数据<br>
2、从需求的交读减少这种需求:主要是不做类似的需求(直接跳转到几百万页之后的具体某一页，只允许逐页查看或者按照给定的路线走，这样可以预测，可缓存)以及防止ID泄露且连续被人攻击<br>
 解决超大分页 其实主要是看缓存，可预测性的提前查看到内容，缓存到redis的l-v数据库，直接返回即可
### 5. 关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过? ###
 1、首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写<br>
 2、分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句尽可能命中索引<br>
 3、如果对语句以及无法进行优化，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表<br>
### 6、上面提到横向分表和纵向分表,可以分别举一个适合他们的例子吗? ###
横向分表就是按行分表，假设我们有一张用户表，主键是自增ID且同时是用户的ID，数据量较大，有1亿多条，那么此时放在一张表里的查询效果就不太理想，我们可以根据主键ID进行分表，这样就可以按照ID分为0-99分为100个表，每个表100w数据，这是的查询效率无疑更好<br>
纵向分表就是按列分表，假设我们有一个文章表，包含字段id-摘要-内容，而系统中的展示形式是刷新出一个列表，列表中仅展示摘要，当用户点击某篇文章进入详情时才需要正文内容，此时，如果数据量大，将内容这个很大且不经常使用的列放在一起会拖慢表的查询速度，我们可以将上面的表分为两张id-摘要,id-内容，这样就可以优化<br>
### 7、存储过程是什么，它的有点 ###
存储过程是一些预编译的sql语句:<br>
 1、存储过程可以说是一个记录集，它是由一些sql语句组成的代码块，然后再给这个代码块取一个名字，再用到这个功能的时候 调用它就是了<br>
 2、存储过程是一个预编译的代码块，执行效率比较高，一个存储过程替代大量sql语句，可以降低网络通信量，提高通信速率，可以一定的保证数据安全性<br>
### 8、说一说三个范式 ###
第一范式:每个列都不可以再拆分<br>
第二范式:非主键列完全依赖于主键而不能是依赖于主键的一部分<br>
第三范式:非主键列只依赖于主键，不依赖于其他非主键<br>













